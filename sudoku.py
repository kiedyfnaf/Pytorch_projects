# -*- coding: utf-8 -*-
"""Sudoku.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YM7l_XXfZONrqcYvss2A60d8Vuq64APk
"""

import torch
import numpy as np
import os
import math
import time
import matplotlib.pyplot as plt
from torch import nn
import torch.optim as optim
import torch.nn.functional as F

device = "cuda" if torch.cuda.is_available() else "cpu"
PERCENT = 95

dataset = np.loadtxt('sudoku.csv', delimiter=',', skiprows=1, dtype=str)
sudokus = []
solutions = []
num = 50
# Loop through the dataset to extract puzzles and solutions
for i in range(num):  # Adjust if your dataset has fewer than 1000 rows
    sudoku = dataset[i][0]
    solution = dataset[i][1]

    # Append to the lists
    sudokus.append(sudoku)
    solutions.append(solution)



rows, columns, squares = [], [], []
r = []
c = []
s = []
for i in range(9):
    ro = sudoku[i*9:(i+1)*9]
    r.append(ro)
rows.append(r)
for a in range(9):
    col = ""
    for i in range(9):
        col = col + str(sudoku[a+(i * 9)])
    c.append(col)
columns.append(c)
for box_row in range(0, 9, 3):
    for box_col in range(0, 9, 3):
        sq = ""
        for i in range(3):
            sq += str(sudoku[(box_row + i) * 9 + box_col:(box_row + i) * 9 + box_col + 3])
        s.append(sq)
squares.append(s)
rows = rows[0]
columns = columns[0]
squares = squares[0]
rowss = [[int(char) for char in row] for row in rows]
columnss = [[int(char) for char in row] for row in columns]
squaress = [[int(char) for char in row] for row in squares]
mask = []
for i in range(9):
    for a in range(9):
        help = []
        help.append(rowss[i])
        help.append(columnss[a])
        if -1<i<3:
            mm=0
        if 2<i<6:
            mm =3
        if 5<i<9:
            mm =6
        help.append(squaress[mm+a//3])
        mask.append(help)
mask = np.array(mask)
mask = torch.tensor(mask, dtype=torch.float, device =device)
sudoku = np.array([list(map(int, s)) for s in sudoku])  # Convert strings to integers
solution = np.array([list(map(int, s)) for s in solution])
sudoku = torch.tensor(sudoku, dtype=torch.float, device =device)
solution = torch.tensor(solution, dtype=torch.long, device =device)
solution = solution.view(81)
sudoku = sudoku.reshape(9,9)
sudoku_float = sudoku.to(torch.float).view(1,81)

#sudokus[0]



#sudoku = np.array([list(map(int, s)) for s in sudoku])  # Convert strings to integers
#solution = np.array([list(map(int, s)) for s in solution])
#sudoku[80]

#sudoku = torch.tensor(sudoku, dtype=torch.float, device =device)
#solution = torch.tensor(solution, dtype=torch.long, device =device)

#solution = solution.view(81)
#sudoku = sudoku.reshape(9,9)
#sudoku_float = sudoku.to(torch.float).view(1,81)

#sudoku.shape, solution.shape

class SudokuSolver(nn.Module):
    def __init__(self):
        super(SudokuSolver, self).__init__()
        self.layer1 = nn.Linear(81, 256, bias=False, device=device)
        self.activation1 = nn.ReLU()
        self.layer2 = nn.Linear(256, 512, bias=False, device=device)
        self.activation2 = nn.ReLU()
        self.output = nn.Linear(512, 81*9, bias=False, device=device)  # Output size is 81 * 9 (possible values for each cell)
        self.softmax = nn.Softmax(dim=1)

    def forward(self, x, device):
        x = self.activation1(self.layer1(x))
        x = self.activation2(self.layer2(x))  # New layer and activation
        logits = self.output(x)  # Output logits
        probabilities = logits.view(81, 9)  # Reshape to (81, 9)
        probabilities = self.softmax(probabilities)  # Apply softmax to get probabilities
        return probabilities

    def forward_no_softmax(self, x):
        x = self.activation1(self.layer1(x))
        x = self.activation2(self.layer2(x))  # New layer and activation
        logits = self.output(x)  # Output logits
        probabilities = logits.view(81, 9)  # Reshape to (81, 9)
        return probabilities

    def predict_all_cells(self, sudoku, device):
        with torch.no_grad():
            probabilities = self.forward(sudoku_float, device=device)

            for row in range(9):
                for col in range(9):
                    index = row * 9 + col
                    if sudoku[row][col] != 0:  # Fixed cell with a given number
                        probabilities[index] = torch.zeros_like(probabilities[index])
                    elif sudoku[row][col] == 0:
                        unique_row = torch.unique(mask[index][0])
                        unique_column = torch.unique(mask[index][1])
                        unique_square = torch.unique(mask[index][2])

                        for a in unique_row:
                            if a != 0:  # Check if it's not zero
                                probabilities[index][int(a.item()) - 1] = 0

                        for b in unique_column:
                            if b != 0:  # Check if it's not zero
                                probabilities[index][int(b.item()) - 1] = 0

                        for c in unique_square:
                            if c != 0:  # Check if it's not zero
                                probabilities[index][int(c.item()) - 1] = 0
            return probabilities

    def select_most_confident_cell(self, probabilities):
        most_confident_cell = None
        max_probability = -1
        for i in range(81):
            confidence = probabilities[i].max().item()  # Get the maximum probability
            if confidence > max_probability:
                max_probability = confidence
                most_confident_cell = i
        if most_confident_cell is not None:
            value = torch.argmax(probabilities[most_confident_cell]) + 1
            #print(f"Most confident cell: {most_confident_cell} with value: {value}")
            return most_confident_cell, value, max_probability
        return None, None, max_probability

    def update_constraints(self, sudoku, most_confident_cell, value, rowss, columnss, squaress):
        row = most_confident_cell // 9
        col = most_confident_cell % 9
        sudoku[row][col] = value  # Update the sudoku grid
        rowss[row][col] = value
        columnss[col][row] = value
        sudoku_string = sudoku.view(1,81)

        # Update square constraint with correct offset
        square_index = (row // 3) * 3 + (col // 3)
        square_offset = (row % 3) * 3 + (col % 3)
        squaress[square_index][square_offset] = value

        mask = []
        for i in range(9):
            for a in range(9):
                help = []
                help.append(rowss[i])
                help.append(columnss[a])
                if i<3:
                    mm=0
                elif i<6:
                    mm =3
                elif i<9:
                    mm =6
                help.append(squaress[mm+a//3])
                mask.append(help)
        mask = torch.tensor(mask, dtype=torch.long, device=device)
        sudoku_float = sudoku.to(torch.float).reshape(1,81)
        return sudoku, mask, rowss, columnss, squaress, sudoku_float

    def compute_loss(self, probabilities, solution):
        criterion = nn.CrossEntropyLoss()
        # Assumes model_output is logits of shape [81, 9] and true_labels is in one-hot format
        # We need to convert true_labels from one-hot to indices
        # Calculate loss using model outputs
        loss = criterion(probabilities, solution-1)  # Ensure correct shapes
        return loss

model = SudokuSolver()

optimizer = optim.Adam(model.parameters(), lr=0.001)

for epoch in range(len(sudokus)):
  sudoku = sudokus[epoch]
  solution = solutions[epoch]
  rows, columns, squares = [], [], []
  r = []
  c = []
  s = []
  for i in range(9):
      ro = sudoku[i*9:(i+1)*9]
      r.append(ro)
  rows.append(r)
  for a in range(9):
      col = ""
      for i in range(9):
          col = col + str(sudoku[a+(i * 9)])
      c.append(col)
  columns.append(c)
  for box_row in range(0, 9, 3):
      for box_col in range(0, 9, 3):
          sq = ""
          for i in range(3):
              sq += str(sudoku[(box_row + i) * 9 + box_col:(box_row + i) * 9 + box_col + 3])
          s.append(sq)
  squares.append(s)
  rows = rows[0]
  columns = columns[0]
  squares = squares[0]
  rowss = [[int(char) for char in row] for row in rows]
  columnss = [[int(char) for char in row] for row in columns]
  squaress = [[int(char) for char in row] for row in squares]
  mask = []
  for i in range(9):
      for a in range(9):
          help = []
          help.append(rowss[i])
          help.append(columnss[a])
          if i<3:
              mm=0
          elif i<6:
              mm =3
          elif i<9:
              mm =6
          help.append(squaress[mm+a//3])
          mask.append(help)
  mask = np.array(mask)
  mask = torch.tensor(mask, dtype=torch.float, device =device)
  sudoku = np.array([list(map(int, s)) for s in sudoku])  # Convert strings to integers
  solution = np.array([list(map(int, s)) for s in solution])
  sudoku = torch.tensor(sudoku, dtype=torch.float, device =device)
  solution = torch.tensor(solution, dtype=torch.long, device =device)
  solution = solution.view(81)
  sudoku = sudoku.reshape(9,9)
  sudoku_float = sudoku.to(torch.float).view(1,81)
  for i in range(81):
      probabilities = model.predict_all_cells(sudoku, device)
      most_confident_cell, value, max_probability = model.select_most_confident_cell(probabilities)
      sudoku, mask,rowss,columnss,squaress,sudoku_float = model.update_constraints(sudoku, most_confident_cell, value, rowss, columnss, squaress)
      if max_probability == 0:
          break
  probabilities = model.forward_no_softmax(sudoku_float)
  loss = model.compute_loss(probabilities, solution)
  model.train()
  optimizer.zero_grad()  # Zero the gradients from the previous step
  loss.backward()        # Compute gradients
  optimizer.step()
  model.eval()
  print(loss)
# Print the modified Sudoku grid
print("Final Sudoku grid:")
for row in sudoku:
    print(row)
print(loss)

print(epoch)